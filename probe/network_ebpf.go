//go:build linux && amd64
// +build linux,amd64

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -target amd64 bpf bpf/counter.c

package probe

import (
	"errors"
	"fmt"
	"io"
	"net"
	"time"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
	"github.com/vishvananda/netlink"
)

// EBPFFlowKey matches the C struct flow_key for tracking connections
type EBPFFlowKey struct {
	SrcIP    uint32
	DstIP    uint32
	SrcPort  uint16
	DstPort  uint16
	Protocol uint8
	Pad      [3]uint8 // padding for alignment
}

// EBPFFlowStats matches the C struct flow_stats for tracking packets and bytes
type EBPFFlowStats struct {
	Packets uint64
	Bytes   uint64
}

// EBPFCollector implements eBPF-based network traffic collection
type EBPFCollector struct {
	objs       *bpfObjects
	xdpCloser  io.Closer
	iface      *net.Interface
	pollTicker *time.Ticker
	stopCh     chan struct{}
	parent     *NetworkTrafficCollector
}

// legacyXDPCloser handles cleanup for legacy netlink-based XDP attach
type legacyXDPCloser struct {
	link netlink.Link
}

func (c *legacyXDPCloser) Close() error {
	return netlink.LinkSetXdpFd(c.link, -1)
}

// NewEBPFCollector creates a new eBPF-based network collector
func NewEBPFCollector(parent *NetworkTrafficCollector, ifaceName string) (*EBPFCollector, error) {
	// Get interface
	iface, err := net.InterfaceByName(ifaceName)
	if err != nil {
		return nil, fmt.Errorf("interface %q not found: %w", ifaceName, err)
	}

	return &EBPFCollector{
		iface:  iface,
		stopCh: make(chan struct{}),
		parent: parent,
	}, nil
}

// Start loads the BPF program and attaches it to the interface
func (e *EBPFCollector) Start(pollInterval time.Duration) error {
	// 1. Remove memory limits for eBPF
	if err := rlimit.RemoveMemlock(); err != nil {
		return fmt.Errorf("failed to remove memlock: %w", err)
	}

	// 2. Load the compiled BPF objects (generated by bpf2go)
	e.objs = &bpfObjects{}
	opts := &ebpf.CollectionOptions{
		Programs: ebpf.ProgramOptions{
			LogLevel: ebpf.LogLevelBranch | ebpf.LogLevelStats,
			LogSize:  1 << 20,
		},
	}
	if err := loadBpfObjects(e.objs, opts); err != nil {
		var ve *ebpf.VerifierError
		if errors.As(err, &ve) {
			return fmt.Errorf("BPF verifier error: %+v", ve)
		}
		return fmt.Errorf("failed to load BPF objects: %w", err)
	}

	// 3. Disable filtering (monitoring only mode)
	if err := e.objs.Config.Put(uint32(0), uint32(0)); err != nil {
		e.objs.Close()
		return fmt.Errorf("failed to set config: %w", err)
	}

	// 4. Attach XDP program to interface
	// Try bpf_link first (kernel >= 5.7), fallback to legacy netlink attach
	l, err := link.AttachXDP(link.XDPOptions{
		Program:   e.objs.CountPackets,
		Interface: e.iface.Index,
	})
	if err != nil {
		// Fallback to legacy netlink-based XDP attach for kernel < 5.7
		nlLink, err := netlink.LinkByIndex(e.iface.Index)
		if err != nil {
			e.objs.Close()
			return fmt.Errorf("failed to get netlink interface: %w", err)
		}
		if err := netlink.LinkSetXdpFd(nlLink, e.objs.CountPackets.FD()); err != nil {
			e.objs.Close()
			return fmt.Errorf("failed to attach XDP (legacy): %w", err)
		}
		e.xdpCloser = &legacyXDPCloser{link: nlLink}
	} else {
		e.xdpCloser = l
	}

	// 5. Start polling goroutine
	e.pollTicker = time.NewTicker(pollInterval)
	e.stopCh = make(chan struct{})

	go e.pollStats()

	return nil
}

// pollStats periodically reads stats from BPF maps and updates the parent collector
func (e *EBPFCollector) pollStats() {
	for {
		select {
		case <-e.stopCh:
			return
		case <-e.pollTicker.C:
			e.readStats()
		}
	}
}

// readStats reads flow statistics from the BPF map
func (e *EBPFCollector) readStats() {
	if e.objs == nil || e.objs.IpStats == nil {
		return
	}

	var (
		key   EBPFFlowKey
		value EBPFFlowStats
	)

	// Clear previous stats and read new ones
	e.parent.ClearStats()

	iter := e.objs.IpStats.Iterate()
	for iter.Next(&key, &value) {
		srcIP := Uint32ToIP(key.SrcIP).String()
		dstIP := Uint32ToIP(key.DstIP).String()
		proto := ProtocolNumberToName(key.Protocol)

		e.parent.RecordTraffic(
			srcIP,
			key.SrcPort,
			dstIP,
			key.DstPort,
			proto,
			value.Packets,
			value.Bytes,
		)
	}
}

// Stop detaches the XDP program and cleans up resources
func (e *EBPFCollector) Stop() error {
	// Stop polling
	if e.pollTicker != nil {
		e.pollTicker.Stop()
	}
	if e.stopCh != nil {
		close(e.stopCh)
	}

	// Detach XDP
	if e.xdpCloser != nil {
		if err := e.xdpCloser.Close(); err != nil {
			return fmt.Errorf("failed to detach XDP: %w", err)
		}
	}

	// Close BPF objects
	if e.objs != nil {
		e.objs.Close()
	}

	return nil
}

// GetInterface returns the interface the collector is attached to
func (e *EBPFCollector) GetInterface() *net.Interface {
	return e.iface
}

// ReadStatsOnce reads stats once without polling (for testing)
func (e *EBPFCollector) ReadStatsOnce() ([]NetworkTraffic, error) {
	if e.objs == nil || e.objs.IpStats == nil {
		return nil, fmt.Errorf("BPF objects not loaded")
	}

	var (
		key    EBPFFlowKey
		value  EBPFFlowStats
		result []NetworkTraffic
	)

	iter := e.objs.IpStats.Iterate()
	for iter.Next(&key, &value) {
		srcIP := Uint32ToIP(key.SrcIP).String()
		dstIP := Uint32ToIP(key.DstIP).String()
		proto := ProtocolNumberToName(key.Protocol)

		result = append(result, NetworkTraffic{
			SrcIP:     srcIP,
			SrcPort:   key.SrcPort,
			DstIP:     dstIP,
			DstPort:   key.DstPort,
			Protocol:  proto,
			Packets:   value.Packets,
			Bytes:     value.Bytes,
			Timestamp: time.Now(),
		})
	}

	return result, nil
}
