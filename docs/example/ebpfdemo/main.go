//go:generate go run github.com/cilium/ebpf/cmd/bpf2go bpf bpf/counter.c

package main

import (
	"encoding/binary"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
	"github.com/vishvananda/netlink"
)

// FilterRule matches the C struct filter_rule
type FilterRule struct {
	SrcIP    uint32
	DstIP    uint32
	SrcPort  uint16
	DstPort  uint16
	Protocol uint8
	Action   uint8 // 0=count, 1=drop, 2=pass
	Enabled  uint8
	Pad      uint8 // padding for alignment
}

// FlowKey matches the C struct flow_key for tracking connections
type FlowKey struct {
	SrcIP    uint32
	DstIP    uint32
	SrcPort  uint16
	DstPort  uint16
	Protocol uint8
	Pad      [3]uint8 // padding for alignment
}

// FlowStats matches the C struct flow_stats for tracking packets and bytes
type FlowStats struct {
	Packets uint64
	Bytes   uint64
}

var (
	ifaceName     = flag.String("i", "", "network interface name (e.g., eth0, ens33)")
	enableFilter  = flag.Bool("filter", false, "enable filtering mode")
	addRule       = flag.String("add", "", "add filter rule: src_ip,dst_ip,src_port,dst_port,proto,action")
	listRules     = flag.Bool("list", false, "list current filter rules")
	statsInterval = flag.Duration("interval", 5*time.Second, "stats print interval")
)

func main() {
	flag.Parse()

	// 1. Remove memory limits for eBPF
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatal(err)
	}

	// 2. Load the compiled BPF objects (generated by bpf2go)
	objs := bpfObjects{}
	opts := &ebpf.CollectionOptions{
		Programs: ebpf.ProgramOptions{
			LogLevel:     ebpf.LogLevelBranch | ebpf.LogLevelStats,
			LogSizeStart: 1 << 20,
		},
	}
	if err := loadBpfObjects(&objs, opts); err != nil {
		var ve *ebpf.VerifierError
		if errors.As(err, &ve) {
			log.Printf("Verifier log:\n%+v", ve)
		}
		log.Fatal(err)
	}
	defer objs.Close()

	// 3. Enable/disable filtering
	var filterEnabled uint32
	if *enableFilter {
		filterEnabled = 1
		fmt.Println("Filtering mode: ENABLED")
	} else {
		fmt.Println("Filtering mode: DISABLED (monitoring only)")
	}
	if err := objs.Config.Put(uint32(0), filterEnabled); err != nil {
		log.Printf("Warning: failed to set config: %v", err)
	}

	// 4. Add filter rule if specified
	if *addRule != "" {
		rule, err := parseRule(*addRule)
		if err != nil {
			log.Fatalf("Invalid rule: %v", err)
		}
		if err := objs.FilterRules.Put(uint32(0), rule); err != nil {
			log.Fatalf("Failed to add rule: %v", err)
		}
		fmt.Printf("Added filter rule: %+v\n", rule)
	}

	// 5. Find network interface
	iface, err := getInterface(*ifaceName)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Attaching XDP to interface: %s (index %d)\n", iface.Name, iface.Index)

	// Try bpf_link first (kernel >= 5.7), fallback to legacy netlink attach
	var xdpCloser io.Closer
	l, err := link.AttachXDP(link.XDPOptions{
		Program:   objs.CountPackets,
		Interface: iface.Index,
	})
	if err != nil {
		// Fallback to legacy netlink-based XDP attach for kernel < 5.7
		fmt.Printf("bpf_link not supported, using legacy netlink attach...\n")
		nlLink, err := netlink.LinkByIndex(iface.Index)
		if err != nil {
			log.Fatalf("failed to get netlink interface: %v", err)
		}
		if err := netlink.LinkSetXdpFd(nlLink, objs.CountPackets.FD()); err != nil {
			log.Fatalf("failed to attach XDP (legacy): %v", err)
		}
		xdpCloser = &legacyXDPCloser{link: nlLink}
		fmt.Println("XDP attached using legacy netlink method")
	} else {
		xdpCloser = l
		fmt.Println("XDP attached using bpf_link")
	}
	defer xdpCloser.Close()

	// Handle graceful shutdown
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

	// 6. Periodically poll the map for CMDB metrics
	ticker := time.NewTicker(*statsInterval)
	fmt.Println("\nMonitoring traffic (Ctrl+C to stop)...")
	fmt.Println("=========================================")

	for {
		select {
		case <-sig:
			fmt.Println("\nShutting down...")
			return
		case <-ticker.C:
			printStats(&objs)
		}
	}
}

// legacyXDPCloser handles cleanup for legacy netlink-based XDP attach
type legacyXDPCloser struct {
	link netlink.Link
}

func (c *legacyXDPCloser) Close() error {
	return netlink.LinkSetXdpFd(c.link, -1)
}

func printStats(objs *bpfObjects) {
	var (
		key   FlowKey
		value FlowStats
	)

	fmt.Printf("\n--- Network Stats [%s] ---\n", time.Now().Format("15:04:05"))
	fmt.Printf("  %-15s | %-15s | %-10s | %-10s | %-8s | %-10s | %s\n", "SRC IP", "DST IP", "SRC PORT", "DST PORT", "PROTO", "PACKETS", "BYTES")
	fmt.Println("  " + strings.Repeat("-", 95))

	// Print flow stats
	iter := objs.IpStats.Iterate()
	for iter.Next(&key, &value) {
		srcIP := uint32ToIP(key.SrcIP)
		dstIP := uint32ToIP(key.DstIP)
		proto := protoToName(key.Protocol)
		fmt.Printf("  %-15s | %-15s | %-10d | %-10d | %-8s | %-10d | %d\n",
			srcIP, dstIP, key.SrcPort, key.DstPort, proto, value.Packets, value.Bytes)
	}

	// Print rule match stats if filtering is enabled
	if *enableFilter {
		fmt.Println("\n--- Rule Match Stats ---")
		for i := uint32(0); i < 16; i++ {
			var count uint64
			if err := objs.RuleStats.Lookup(i, &count); err == nil && count > 0 {
				fmt.Printf("  Rule %d: %d matches\n", i, count)
			}
		}
	}
}

// protoToName converts protocol number to human-readable name
func protoToName(proto uint8) string {
	switch proto {
	case 1:
		return "ICMP"
	case 2:
		return "IGMP"
	case 6:
		return "TCP"
	case 17:
		return "UDP"
	case 47:
		return "GRE"
	case 50:
		return "ESP"
	case 51:
		return "AH"
	case 89:
		return "OSPF"
	case 112:
		return "VRRP"
	case 132:
		return "SCTP"
	default:
		return fmt.Sprintf("%d", proto)
	}
}

// parseRule parses a rule string: "src_ip,dst_ip,src_port,dst_port,proto,action"
// Use "0" or "*" for any/wildcard
// proto: tcp, udp, or number
// action: count, drop, pass
func parseRule(s string) (FilterRule, error) {
	parts := strings.Split(s, ",")
	if len(parts) != 6 {
		return FilterRule{}, fmt.Errorf("expected 6 parts: src_ip,dst_ip,src_port,dst_port,proto,action")
	}

	rule := FilterRule{Enabled: 1}

	// Source IP
	if parts[0] != "0" && parts[0] != "*" {
		ip := net.ParseIP(parts[0])
		if ip == nil {
			return FilterRule{}, fmt.Errorf("invalid source IP: %s", parts[0])
		}
		rule.SrcIP = ipToUint32(ip.To4())
	}

	// Destination IP
	if parts[1] != "0" && parts[1] != "*" {
		ip := net.ParseIP(parts[1])
		if ip == nil {
			return FilterRule{}, fmt.Errorf("invalid destination IP: %s", parts[1])
		}
		rule.DstIP = ipToUint32(ip.To4())
	}

	// Source port
	if parts[2] != "0" && parts[2] != "*" {
		port, err := strconv.Atoi(parts[2])
		if err != nil || port < 0 || port > 65535 {
			return FilterRule{}, fmt.Errorf("invalid source port: %s", parts[2])
		}
		rule.SrcPort = uint16(port)
	}

	// Destination port
	if parts[3] != "0" && parts[3] != "*" {
		port, err := strconv.Atoi(parts[3])
		if err != nil || port < 0 || port > 65535 {
			return FilterRule{}, fmt.Errorf("invalid destination port: %s", parts[3])
		}
		rule.DstPort = uint16(port)
	}

	// Protocol
	switch strings.ToLower(parts[4]) {
	case "0", "*", "any":
		rule.Protocol = 0
	case "tcp", "6":
		rule.Protocol = 6
	case "udp", "17":
		rule.Protocol = 17
	case "icmp", "1":
		rule.Protocol = 1
	default:
		proto, err := strconv.Atoi(parts[4])
		if err != nil {
			return FilterRule{}, fmt.Errorf("invalid protocol: %s", parts[4])
		}
		rule.Protocol = uint8(proto)
	}

	// Action
	switch strings.ToLower(parts[5]) {
	case "count", "0":
		rule.Action = 0
	case "drop", "1":
		rule.Action = 1
	case "pass", "2":
		rule.Action = 2
	default:
		return FilterRule{}, fmt.Errorf("invalid action: %s (use: count, drop, pass)", parts[5])
	}

	return rule, nil
}

func ipToUint32(ip net.IP) uint32 {
	if ip == nil {
		return 0
	}
	return binary.LittleEndian.Uint32(ip)
}

func uint32ToIP(n uint32) net.IP {
	ip := make(net.IP, 4)
	binary.LittleEndian.PutUint32(ip, n)
	return ip
}

// getInterface returns the specified interface or finds the first non-loopback interface
func getInterface(name string) (*net.Interface, error) {
	if name != "" {
		iface, err := net.InterfaceByName(name)
		if err != nil {
			return nil, fmt.Errorf("interface %q not found: %v", name, err)
		}
		return iface, nil
	}

	// Find first non-loopback interface
	ifaces, err := net.Interfaces()
	if err != nil {
		return nil, err
	}

	fmt.Println("Available interfaces:")
	for _, iface := range ifaces {
		fmt.Printf("  - %s (index %d, flags: %v)\n", iface.Name, iface.Index, iface.Flags)
		// Skip loopback and down interfaces
		if iface.Flags&net.FlagLoopback != 0 || iface.Flags&net.FlagUp == 0 {
			continue
		}
		return &iface, nil
	}

	return nil, fmt.Errorf("no suitable network interface found, specify one with -i flag")
}
